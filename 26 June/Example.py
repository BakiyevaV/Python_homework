from functools import reduce
first_names = ["Елена","Виктор","Николай","Ирина","Андрей","Анна", "Яна"]
last_names = ["Соколова","Петров","Ильин","Оборотова","Костров", "Солдатова","Белкина",]
patronymic = ["Олеговна", "Сергеевич","Савельевич", "Александровна", "Андреевич","Игоревна","Юрьевна"]

full_names = list(map(lambda x, y, k: f"ФИО: {y} {x} {k}", first_names, last_names, patronymic))# Из трех списков формируем один и к каждому элементу добавляем "ФИО: "
print(f"Список содержащий наименование ячейки: {full_names}")

list1 = list(map(str.split, full_names)) #Для дальнейших итераций формируем список списков, где каждый элемент предыдущего списка хранится как отдельный элемент
print(f"Список списков, где каждое ФИО в виде отдельного элемента списка: {list1}")

list2 = list(filter(lambda x: len(x[2])>5,list1))# Формируем список из имен(вторых элементов каждого списка списков list1), которые имеют длину больше 5 символов
print(f" Имена с длиной больше 5 символов: {list2}")

def f(a,b):# создаем функцию с двумя аргументами, являющимися элементами предыдущего списка.
    if len(a[2])>len(b[2]):# Обращаемся к именам в составе каждого списка(ФИО). И определяем соответствие условию.
        return a
    else:
        return b

max_name = reduce(f, list2)#""" Функция проверила первые два элемента списка
#после определения наибольшего, функция берет слежующий элемент в списке и снова делает сравнение.
#действие совершается, пока не останется одно значение-результат.
max_name1 = f"{max_name[0]} {max_name[1]} {max_name[2]} {max_name[3]}"
full_names.index(max_name1)
print(f" Самое длинное имя находится в составе элемента: {max_name} под индексом: {full_names.index(max_name1)} в списке 'full_names'")
